<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <title>Clip Feed</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root { color-scheme: dark light; }
        * { box-sizing: border-box; }
        body { margin:0; font-family:-apple-system, system-ui, Segoe UI, Roboto, "Noto Sans KR", sans-serif; background:#0b0b0b; color:#f2f2f2; }
        .wrap { max-width:680px; margin:0 auto; padding:16px; }
        header { position:sticky; top:0; z-index:10; backdrop-filter:saturate(180%) blur(8px); background:rgba(0,0,0,.6); border-bottom:1px solid rgba(255,255,255,.08); }
        header .bar { display:flex; align-items:center; justify-content:space-between; padding:12px 16px; }
        .title { font-weight:800; letter-spacing:.3px; }
        .feed { display:flex; flex-direction:column; gap:18px; padding:16px; }
        .card { background:#111; border:1px solid #222; border-radius:14px; overflow:hidden; }
        .card .meta { display:flex; align-items:center; gap:10px; padding:12px 14px; border-bottom:1px solid #1b1b1b; }
        .avatar { width:34px; height:34px; border-radius:50%; background:#333; flex:0 0 auto; }
        .name { font-weight:700; font-size:14px; }
        .name a { color:inherit; text-decoration:none; }
        .name a:hover { text-decoration:underline; }
        .time { color:#a0a0a0; font-size:12px; }
        .caption { padding:10px 14px 0 14px; color:#e9e9e9; font-size:14px; line-height:1.45; }
        .video-box { position:relative; }
        video { width:100%; display:block; background:#000; max-height:70vh; }
        .actions { display:flex; align-items:center; gap:10px; padding:10px 14px; border-top:1px solid #1b1b1b; }
        .btn { padding:8px 12px; border:1px solid #2a2a2a; background:#1a1a1a; color:#fff; border-radius:10px; font-size:13px; cursor:pointer; }
        .btn:disabled { opacity:.5; cursor:not-allowed; }
        .counts { margin-left:auto; color:#bdbdbd; font-size:12px; }
        .comments { border-top:1px solid #1b1b1b; padding:10px 14px 14px; display:flex; flex-direction:column; gap:10px; }
        .comment-list { display:flex; flex-direction:column; gap:8px; max-height:240px; overflow:auto; padding-right:4px; }
        .comment-item { display:flex; gap:10px; align-items:flex-start; }
        .comment-item .who { font-weight:700; font-size:12px; }
        .comment-item .text { font-size:13px; color:#e6e6e6; }
        .comment-new { display:flex; gap:8px; }
        .comment-new input { flex:1; padding:10px 12px; border-radius:10px; border:1px solid #2a2a2a; background:#141414; color:#fff; outline:none; }
        .loadmore { display:block; width:100%; margin:10px 0 24px; }
        .hidden { display:none !important; }
        .toast { position:fixed; left:50%; bottom:24px; transform:translateX(-50%); background:#222; color:#fff; padding:10px 14px; border-radius:10px; border:1px solid #333; z-index:9999; font-size:13px; }

        /* ====== 신고 모달(하단 시트) ====== */
        .r-dim{position:fixed;inset:0;background:rgba(0,0,0,.45);opacity:0;pointer-events:none;transition:.2s;z-index:50}
        .r-dim.show{opacity:1;pointer-events:auto}
        .r-sheet{position:fixed;left:50%;transform:translateX(-50%) translateY(100%);bottom:0;width:min(680px,100vw);max-height:75vh;background:#111;border:1px solid #222;border-radius:16px 16px 0 0;box-shadow:0 -10px 24px rgba(0,0,0,.35);transition:.25s;z-index:51;display:flex;flex-direction:column}
        .r-sheet.show{transform:translateX(-50%) translateY(0)}
        .r-head{display:flex;align-items:center;gap:8px;padding:12px 14px;border-bottom:1px solid #1b1b1b}
        .r-title{font-weight:800}
        .r-body{padding:10px 14px;overflow:auto}
        .r-row{display:flex;gap:10px;align-items:center;margin:8px 0}
        .r-detail{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #2a2a2a;background:#141414;color:#fff;min-height:72px}
        .r-actions{display:flex;gap:10px;justify-content:flex-end;padding:10px 14px;border-top:1px solid #1b1b1b}

        @media (prefers-color-scheme: light) {
            body { background:#f7f7f8; color:#111; }
            header { background:rgba(255,255,255,.7); border-color:rgba(0,0,0,.06); }
            .card { background:#fff; border-color:#ececec; }
            .meta { border-color:#eee; }
            .actions { border-color:#eee; }
            .comments { border-color:#eee; }
            .btn { background:#fafafa; color:#111; border-color:#eaeaea; }
            .comment-new input { background:#fff; color:#111; border-color:#eaeaea; }
            .toast { background:#111; }
            .r-sheet{background:#fff;border-color:#eaeaea}
            .r-detail{background:#fff;color:#111;border-color:#eaeaea}
        }
    </style>
</head>
<body>
<header>
    <div class="bar wrap">
        <div class="title">Clip Feed</div>
        <button id="refreshBtn" class="btn">새로고침</button>
    </div>
</header>

<main class="wrap">
    <section id="feed" class="feed"></section>
    <button id="loadMore" class="btn loadmore hidden">더 불러오기</button>
</main>

<script>
    // ========== AUTH ==========
    function getToken() {
        const t = localStorage.getItem('token') || localStorage.getItem('jwt');
        if (!t) return null;
        return t.startsWith('Bearer ') ? t : `Bearer ${t}`;
    }

    // ========== STATE / UTILS ==========
    const state = { page: 0, size: 10, totalPages: null, loading: false };

    function toast(m) {
        const t = document.createElement('div');
        t.className = 'toast';
        t.textContent = m;
        document.body.appendChild(t);
        setTimeout(()=>t.remove(), 1400);
    }

    function pick(x) {
        if (Array.isArray(x)) return x;
        if (x && Array.isArray(x.content)) return x.content;
        return [];
    }

    function pageMeta(x) {
        if (!x || Array.isArray(x)) return { number: 0, totalPages: 1 };
        return { number: x.number ?? 0, totalPages: x.totalPages ?? 1 };
    }

    function read(obj, path) {
        return path.split('.').reduce((acc, k) => (acc && acc[k] != null ? acc[k] : undefined), obj);
    }
    function resolveName(obj, fallback) {
        const candidates = [
            'authorName','memberName','username','name','writerName','uploaderName',
            'createdBy.name','author.name','member.name','user.name','owner.name','creator.name',
            'loginId','member.loginId','user.loginId','authorLoginId'
        ];
        for (const p of candidates) {
            const v = read(obj, p);
            if (typeof v === 'string' && v.trim().length > 0) return v.trim();
        }
        return fallback;
    }
    function likeCountOf(c){ return c.likeCount ?? (Array.isArray(c.likes) ? c.likes.length : 0); }
    function commentCountOf(c){ return c.commentCount ?? (Array.isArray(c.comments) ? c.comments.length : 0); }

    // ========== MEMBER CACHE ==========
    const memberNameCache = new Map();
    let membersLoaded = false;

    async function ensureMembersLoaded() {
        if (membersLoaded) return;
        try {
            const token = getToken();
            const res = await fetch('/api/members', { headers: token ? { Authorization: token } : {} });
            if (!res.ok) return;
            const data = await res.json();
            const arr = Array.isArray(data) ? data : (Array.isArray(data?.content) ? data.content : []);
            for (const m of arr) {
                const id = m.id ?? m.memberId ?? m.userId;
                const name = (m.name ?? m.username ?? m.loginId ?? '').toString();
                if (id != null && name) memberNameCache.set(String(id), name);
            }
        } catch {}
        finally {
            membersLoaded = true;
            refreshAuthorNames();
        }
    }

    function clipAuthorFromCache(clip) {
        const ids = [
            clip.memberId, clip.authorId, clip.uploaderId, clip.ownerId,
            read(clip, 'member.id'), read(clip, 'author.id'), read(clip, 'user.id'), read(clip, 'creator.id'),
        ].filter(v => v != null);
        for (const id of ids) {
            const nm = memberNameCache.get(String(id));
            if (nm) return nm;
        }
        return null;
    }

    function setName(el, clip) {
        const display = resolveName(clip, null) ?? (clipAuthorFromCache(clip) ?? '작성자');
        if (clip && clip.uploaderId != null) {
            el.innerHTML = '';
            const a = document.createElement('a');
            a.href = `/user.html?userId=${encodeURIComponent(clip.uploaderId)}`;
            a.textContent = display;
            el.appendChild(a);
        } else {
            el.textContent = display;
        }
    }

    function refreshAuthorNames() {
        document.querySelectorAll('.card').forEach(card => {
            const clip = card._clip;
            if (!clip) return;
            const el = card.querySelector('.name');
            if (!el) return;
            setName(el, clip);
        });
    }

    // ========== SAVED (저장한 클립) 상태 캐시 ==========
    let savedKnown = false;
    let savedSet = new Set(); // String(clipId)

    async function ensureSavedLoaded() {
        if (savedKnown) return;
        try {
            const data = await getJson('/api/me/saved?page=0&size=200');
            const list = pick(data);
            savedSet = new Set(list.map(x => String(x.id)));
        } catch (e) {
            // 못 불러와도 기능 자체(토글)는 동작하게 둠
        } finally {
            savedKnown = true;
            refreshSavedButtons();
        }
    }

    function refreshSavedButtons(){
        if (!savedKnown) return;
        document.querySelectorAll('.save-btn').forEach(btn=>{
            const id = btn.dataset.clipId;
            if (savedSet.has(String(id))) {
                btn.dataset.saved = '1';
                btn.textContent = '저장 해제';
            } else {
                btn.dataset.saved = '0';
                btn.textContent = '저장';
            }
        });
    }

    async function toggleSave(clipId, btn){
        const isSaved = (btn.dataset.saved === '1') || savedSet.has(String(clipId));
        try{
            if (isSaved) {
                // 우선 DELETE 시도, 실패 시 POST(토글) 폴백
                try{
                    await getJson(`/api/clips/${clipId}/save`, { method:'DELETE' });
                }catch{
                    await getJson(`/api/clips/${clipId}/save`, { method:'POST' });
                }
                savedSet.delete(String(clipId));
                btn.dataset.saved = '0';
                btn.textContent = '저장';
                toast('저장 해제됨');
            } else {
                // 우선 POST 시도, 실패 시 DELETE(토글) 폴백
                try{
                    await getJson(`/api/clips/${clipId}/save`, { method:'POST' });
                }catch{
                    await getJson(`/api/clips/${clipId}/save`, { method:'DELETE' });
                }
                savedSet.add(String(clipId));
                btn.dataset.saved = '1';
                btn.textContent = '저장 해제';
                toast('저장됨');
            }
            savedKnown = true;
        }catch(e){
            console.error(e);
            const msg = (e && e.message || '').toUpperCase().includes('UNAUTHORIZED') ? '로그인이 필요합니다.' : '실패(네트워크/서버 확인)';
            toast(msg);
        }
    }

    // ========== HTTP ==========
    async function getJson(url, opt = {}) {
        const headers = opt.headers ? {...opt.headers} : {};
        if (!headers['Content-Type'] && opt.method && opt.method !== 'GET') headers['Content-Type'] = 'application/json';
        const token = getToken();
        if (token) headers['Authorization'] = token;
        const res = await fetch(url, { ...opt, headers });
        if (!res.ok) {
            const txt = await res.text().catch(()=> '');
            throw new Error(txt || 'request failed');
        }
        const ct = res.headers.get('Content-Type') || '';
        if (ct.includes('application/json')) return res.json();
        return res.text().catch(()=>null);
    }

    // ========== FEED ==========
    async function loadFeed(reset = false) {
        if (state.loading) return;
        state.loading = true;
        try {
            if (reset) { state.page = 0; state.totalPages = null; document.getElementById('feed').innerHTML = ''; }
            const data = await getJson(`/api/clips/feed?page=${state.page}&size=${state.size}`);
            const items = pick(data);
            const meta = pageMeta(data);
            state.totalPages = meta.totalPages;
            renderFeed(items, state.page > 0);
            const moreBtn = document.getElementById('loadMore');
            if (state.page + 1 < state.totalPages) moreBtn.classList.remove('hidden');
            else moreBtn.classList.add('hidden');

            refreshAuthorNames();
            ensureSavedLoaded(); // 저장 상태 로딩 후 버튼 라벨 갱신
        } catch (e) {
            toast('피드 불러오기 실패');
            console.error(e);
        } finally {
            state.loading = false;
        }
    }

    function renderFeed(clips, append) {
        const feed = document.getElementById('feed');
        const frag = document.createDocumentFragment();
        clips.forEach(c => frag.appendChild(buildClipCard(c)));
        if (append) feed.appendChild(frag); else { feed.innerHTML = ''; feed.appendChild(frag); }
    }

    function fmtTime(s) {
        try { return s ? new Date(s).toLocaleString() : ''; } catch { return ''; }
    }

    // ====== 신고 모달 ======
    const REPORT_REASONS = [
        { key:'MISINFO_SCAM',   label:'허위 정보/사기' },
        { key:'INAPPROPRIATE',  label:'부적절한 콘텐츠' },
        { key:'VIOLENCE_CRIME', label:'폭력·학대·범죄' },
        { key:'SEXUAL_CONTENT', label:'성적인 콘텐츠' },
    ];

    function openReportSheet(clipId){
        const dim = document.createElement('div');
        dim.className = 'r-dim';
        const sheet = document.createElement('section');
        sheet.className = 'r-sheet';
        sheet.setAttribute('role','dialog');
        sheet.setAttribute('aria-modal','true');

        const head = document.createElement('div');
        head.className = 'r-head';
        const title = document.createElement('div');
        title.className = 'r-title';
        title.textContent = '신고하기';
        const closeBtn = document.createElement('button');
        closeBtn.className='btn';
        closeBtn.textContent='닫기';
        closeBtn.style.marginLeft='auto';
        closeBtn.addEventListener('click', close);
        head.appendChild(title); head.appendChild(closeBtn);

        const body = document.createElement('div');
        body.className = 'r-body';

        const group = document.createElement('div');
        REPORT_REASONS.forEach((r,idx)=>{
            const row = document.createElement('label');
            row.className='r-row';
            const radio = document.createElement('input');
            radio.type='radio'; radio.name='report-reason'; radio.value=r.key;
            if(idx===0) radio.checked = true;
            const span = document.createElement('span'); span.textContent = r.label;
            row.appendChild(radio); row.appendChild(span);
            group.appendChild(row);
        });

        const detail = document.createElement('textarea');
        detail.className='r-detail';
        detail.placeholder='설명(선택)';

        body.appendChild(group);
        body.appendChild(detail);

        const acts = document.createElement('div');
        acts.className='r-actions';
        const submit = document.createElement('button');
        submit.className='btn';
        submit.textContent='신고 접수';
        submit.addEventListener('click', async ()=>{
            try{
                const sel = sheet.querySelector('input[name="report-reason"]:checked');
                const reason = sel ? sel.value : REPORT_REASONS[0].key;
                const payload = { reason, detail: detail.value || '' };
                await getJson(`/api/reports/clips/${clipId}`, { method:'POST', body: JSON.stringify(payload) });
                toast('신고가 접수되었습니다.');
                close();
            }catch(e){
                console.error(e);
                const msg = (e && e.message || '').toUpperCase().includes('UNAUTHORIZED') ? '로그인이 필요합니다.' : '신고 접수 실패';
                toast(msg);
            }
        });
        acts.appendChild(submit);

        sheet.appendChild(head);
        sheet.appendChild(body);
        sheet.appendChild(acts);

        function close(){
            dim.classList.remove('show');
            sheet.classList.remove('show');
            setTimeout(()=>{ dim.remove(); sheet.remove(); }, 200);
            document.removeEventListener('keydown', onEsc);
        }
        function onEsc(ev){ if(ev.key==='Escape') close(); }

        dim.addEventListener('click', close);
        document.addEventListener('keydown', onEsc);

        document.body.appendChild(dim);
        document.body.appendChild(sheet);
        requestAnimationFrame(()=>{ dim.classList.add('show'); sheet.classList.add('show'); });
    }

    function buildClipCard(c) {
        const card = document.createElement('article');
        card.className = 'card';
        card.dataset.clipId = c.id;
        card._clip = c;

        const meta = document.createElement('div');
        meta.className = 'meta';
        const av = document.createElement('div');
        av.className = 'avatar';
        const whoWrap = document.createElement('div');

        const name = document.createElement('div');
        name.className = 'name';
        setName(name, c);
        ensureMembersLoaded();

        const time = document.createElement('div');
        time.className = 'time';
        time.textContent = fmtTime(c.createdAt);
        whoWrap.appendChild(name);
        whoWrap.appendChild(time);
        meta.appendChild(av);
        meta.appendChild(whoWrap);

        const cap = document.createElement('div');
        cap.className = 'caption';
        cap.textContent = c.caption || '';

        const vb = document.createElement('div');
        vb.className = 'video-box';
        const v = document.createElement('video');
        v.controls = true;
        v.playsInline = true;
        v.src = c.videoUrl || '';
        vb.appendChild(v);

        const acts = document.createElement('div');
        acts.className = 'actions';

        const likeBtn = document.createElement('button');
        likeBtn.className = 'btn';
        likeBtn.textContent = '좋아요';
        likeBtn.addEventListener('click', async () => {
            try {
                await getJson(`/api/clips/${c.id}/like`, { method: 'POST' });
                toast('처리됨');
                await refreshCounts(card);
            } catch (e) {
                toast('실패');
                console.error(e);
            }
        });

        const viewBtn = document.createElement('button');
        viewBtn.className = 'btn';
        viewBtn.textContent = '조회수 +1';
        viewBtn.addEventListener('click', async () => {
            try {
                await getJson(`/api/clips/${c.id}/view`, { method: 'POST' });
                toast('처리됨');
                await refreshCounts(card);
            } catch (e) {
                toast('실패');
                console.error(e);
            }
        });

        /* ⬇️ 저장 버튼 */
        const saveBtn = document.createElement('button');
        saveBtn.className = 'btn save-btn';
        saveBtn.dataset.clipId = c.id;
        saveBtn.dataset.saved = '0';
        saveBtn.textContent = '저장';
        saveBtn.addEventListener('click', ()=> toggleSave(c.id, saveBtn));

        /* 신고 버튼 */
        const reportBtn = document.createElement('button');
        reportBtn.className = 'btn';
        reportBtn.textContent = '신고';
        reportBtn.addEventListener('click', ()=> openReportSheet(c.id));

        const counts = document.createElement('div');
        counts.className = 'counts';
        const likeCnt = likeCountOf(c);
        const commentCnt = commentCountOf(c);
        counts.textContent = `좋아요 ${likeCnt} · 댓글 ${commentCnt}`;
        counts.dataset.likes = likeCnt;
        counts.dataset.comments = commentCnt;

        acts.appendChild(likeBtn);
        acts.appendChild(viewBtn);
        acts.appendChild(saveBtn);   // ⬅️ 추가
        acts.appendChild(reportBtn);
        acts.appendChild(counts);

        const comments = document.createElement('div');
        comments.className = 'comments';
        const list = document.createElement('div');
        list.className = 'comment-list';
        list.id = `comment-list-${c.id}`;
        const form = document.createElement('div');
        form.className = 'comment-new';
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = '댓글을 입력하세요';
        input.id = `comment-input-${c.id}`;
        const send = document.createElement('button');
        send.className = 'btn';
        send.textContent = '등록';
        send.addEventListener('click', async () => {
            const text = input.value.trim();
            if (!text) return;
            try {
                await getJson(`/api/clips/${c.id}/comments`, { method:'POST', body: JSON.stringify({ content: text }) });
                input.value = '';
                toast('댓글 등록됨');
                await loadComments(c.id);
                await bumpCommentCount(card);
            } catch (e) {
                toast('댓글 실패');
                console.error(e);
            }
        });
        form.appendChild(input);
        form.appendChild(send);
        comments.appendChild(list);
        comments.appendChild(form);

        card.appendChild(meta);
        card.appendChild(cap);
        card.appendChild(vb);
        card.appendChild(acts);
        card.appendChild(comments);

        loadComments(c.id);
        return card;
    }

    async function refreshCounts(cardEl) {
        const clipId = cardEl.dataset.clipId;
        try {
            const d = await getJson(`/api/clips/feed?page=0&size=1&id=${clipId}`);
            const list = pick(d);
            const found = list.find(x => String(x.id) === String(clipId));
            if (!found) return;
            cardEl._clip = found;
            const counts = cardEl.querySelector('.counts');
            const likes = likeCountOf(found);
            const comments = commentCountOf(found);
            counts.dataset.likes = likes;
            counts.dataset.comments = comments;
            counts.textContent = `좋아요 ${likes} · 댓글 ${comments}`;
            refreshAuthorNames();
        } catch {}
    }

    async function bumpCommentCount(cardEl) {
        const counts = cardEl.querySelector('.counts');
        const cur = Number(counts.dataset.comments || 0) + 1;
        counts.dataset.comments = String(cur);
        const likes = Number(counts.dataset.likes || 0);
        counts.textContent = `좋아요 ${likes} · 댓글 ${cur}`;
    }

    // ========== COMMENTS & REPLIES ==========
    async function loadComments(clipId) {
        try {
            const data = await getJson(`/api/clips/${clipId}/comments`);
            const list = pick(data);
            renderComments(clipId, list);
        } catch (e) {
            console.error(e);
        }
    }

    function renderComments(clipId, arr) {
        const box = document.getElementById(`comment-list-${clipId}`);
        if (!box) return;
        const frag = document.createDocumentFragment();

        arr.forEach(c => {
            const item = document.createElement('div');
            item.className = 'comment-item';

            const av = document.createElement('div');
            av.className = 'avatar';

            const textWrap = document.createElement('div');

            const who = document.createElement('div');
            who.className = 'who';
            who.textContent = (c.authorName && c.authorName.trim()) ? c.authorName : resolveName(c, '익명');

            const text = document.createElement('div');
            text.className = 'text';
            text.textContent = c.content ?? '';

            const actions = document.createElement('div');
            actions.style.marginTop = '4px';

            const replyToggle = document.createElement('button');
            replyToggle.className = 'btn';
            replyToggle.textContent = '답글';
            replyToggle.style.padding = '4px 8px';
            replyToggle.style.fontSize = '12px';

            const replyBox = document.createElement('div');
            replyBox.style.display = 'none';
            replyBox.style.marginTop = '6px';
            replyBox.className = 'comment-new';

            const replyInput = document.createElement('input');
            replyInput.type = 'text';
            replyInput.placeholder = '답글을 입력하세요';

            const replySend = document.createElement('button');
            replySend.className = 'btn';
            replySend.textContent = '등록';

            replyBox.appendChild(replyInput);
            replyBox.appendChild(replySend);

            const repliesWrap = document.createElement('div');
            repliesWrap.id = `replies-${clipId}-${c.id}`;
            repliesWrap.style.marginTop = '8px';
            repliesWrap.style.paddingLeft = '24px';
            repliesWrap.style.borderLeft = '1px solid #2a2a2a';
            repliesWrap.classList.add('hidden');

            let repliesOpen = false;
            replyToggle.addEventListener('click', async () => {
                repliesOpen = !repliesOpen;
                replyBox.style.display = repliesOpen ? 'flex' : 'none';
                repliesWrap.classList.toggle('hidden', !repliesOpen);
                if (repliesOpen) await loadReplies(clipId, c.id);
            });

            replySend.addEventListener('click', async () => {
                const txt = replyInput.value.trim();
                if (!txt) return;
                try {
                    await postReply(clipId, c.id, txt);
                    replyInput.value = '';
                    await loadReplies(clipId, c.id);
                } catch (e) {
                    console.error(e);
                    toast('답글 등록 실패');
                }
            });

            actions.appendChild(replyToggle);
            textWrap.appendChild(who);
            textWrap.appendChild(text);
            textWrap.appendChild(actions);
            textWrap.appendChild(replyBox);
            textWrap.appendChild(repliesWrap);

            item.appendChild(av);
            item.appendChild(textWrap);
            frag.appendChild(item);
        });

        box.innerHTML = '';
        box.appendChild(frag);
    }

    async function loadReplies(clipId, commentId, page = 0, size = 20) {
        try {
            const data = await getJson(`/api/clips/${clipId}/comments/${commentId}/replies?page=${page}&size=${size}`);
            const list = Array.isArray(data) ? data : (Array.isArray(data?.content) ? data.content : []);
            renderReplies(clipId, commentId, list);
        } catch (e) {
            console.error(e);
            toast('답글 불러오기 실패');
        }
    }

    function renderReplies(clipId, parentCommentId, arr) {
        const box = document.getElementById(`replies-${clipId}-${parentCommentId}`);
        if (!box) return;
        const frag = document.createDocumentFragment();

        arr.forEach(r => {
            const row = document.createElement('div');
            row.className = 'comment-item';
            row.style.marginTop = '6px';

            const av = document.createElement('div');
            av.className = 'avatar';

            const wrap = document.createElement('div');

            const who = document.createElement('div');
            who.className = 'who';
            who.textContent = (r.authorName && r.authorName.trim()) ? r.authorName : resolveName(r, '익명');

            const txt = document.createElement('div');
            txt.className = 'text';
            txt.textContent = r.content ?? '';

            wrap.appendChild(who);
            wrap.appendChild(txt);

            row.appendChild(av);
            row.appendChild(wrap);
            frag.appendChild(row);
        });

        box.innerHTML = '';
        box.appendChild(frag);
    }

    async function postReply(clipId, parentCommentId, content) {
        return getJson(`/api/clips/${clipId}/comments/${parentCommentId}/replies`, {
            method: 'POST',
            body: JSON.stringify({ content })
        });
    }

    // ========== BOOT ==========
    document.getElementById('refreshBtn').addEventListener('click', () => loadFeed(true));
    document.getElementById('loadMore').addEventListener('click', () => {
        if (state.page + 1 < state.totalPages) { state.page += 1; loadFeed(false); }
    });

    ensureMembersLoaded().finally(() => loadFeed(true));
</script>
</body>
</html>